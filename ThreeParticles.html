<!DOCTYPE HTML>
<html lang="en">
    <head>
        <title>three.js particle tutorial</title>
        <meta charset="utf-8">

        <style type="text/css">
            body {
                background-color: #000000;
                margin: 0px;
                overflow: hidden;
            }
        </style>
        
    </head>
    <body>
        <script src="Three.js"></script>

        <script>

stars=[[107,301,241,'Urlen'],[420,0,485,'Maurasi'],[184,208,0,'Kisogo'],[348,52,659,'Jita'],[0,187,436,'Niyabainen'],[17,149,349,'Perimeter'],[172,235,589,'New Caldari']];
target = new THREE.Vector3( 0, 0, 0 );
arc=0;
radius=700;
var isMouseDown = false, onMouseDownPosition, theta = 45, onMouseDownTheta = 45, phi = 60, onMouseDownPhi = 60,    isShiftDown = false;
var rotate=false;
var mouse = { x: 0, y: 0 }, INTERSECTED,position= { x: 0, y: 0 };


            var camera, scene, renderer,projector, particles = [];

            // let's get going! 
            init();

            function init() {

                // Camera params : 
                // field of view, aspect ratio for render output, near and far clipping plane. 
                camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 4000 );
    
                // move the camera backwards so we can see stuff! 
                // default position is 0,0,0. 
                camera.position.z = 700;
                                camera.lookAt( target );
                // the scene contains all the 3D object data
                scene = new THREE.Scene();
                
                // camera needs to go in the scene 
                scene.add(camera);
    
                // and the CanvasRenderer figures out what the 
                // stuff in the scene looks like and draws it!
                renderer = new THREE.CanvasRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );
    
                // the renderer's canvas domElement is added to the body
                document.body.appendChild( renderer.domElement );
                projector = new THREE.Projector();
                makeParticles(); 
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp, false );
                document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
                document.addEventListener( 'DOMMouseScroll', onDocumentMouseWheel, false );
                onMouseDownPosition = new THREE.Vector2();
                // add the mouse move listener
                // render 30 times a second (should also look 
                // at requestAnimationFrame) 
                setInterval(update,1000/30); 
            
            }

            // the main update function, called 30 times a second

            function update() {
                        

                var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
                projector.unprojectVector( vector, camera );
                var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

                var intersects = ray.intersectObjects( scene.children );

                if ( intersects.length > 0 ) {
                        if ( INTERSECTED != intersects[ 0 ].object ) {
                             INTERSECTED = intersects[ 0 ].object;
                          document.getElementById("test").style.left=(position.x+30)+"px"; 
                          document.getElementById("test").style.top=(position.y-5)+"px";
                          document.getElementById("test").innerHTML=INTERSECTED.name;
                        document.getElementById("test").style.display="block";
                        }
                }
                else
                {
                        document.getElementById("test").style.display="none";
                }

                if (rotate)
                { 
                      arc=(arc>6.28)? 0 : arc+0.01;
                      arcx=Math.floor(Math.cos(arc)*radius);
                      arcz=Math.floor(Math.sin(arc)*radius);
                      camera.position.x=arcx;
                      camera.position.z=arcz;
                }                       
                camera.lookAt( target );
                renderer.render( scene, camera );

            }

            
            function makeParticles() { 
                
                var particle, material; 

                for ( var star in stars ) {
                    material = new THREE.ParticleCanvasMaterial( { color: 0xffffff, program: particleRender } );
                    particle = new THREE.Particle(material);
                    particle.position.x = stars[star][0]-210;
                    particle.position.y = stars[star][1]-210;
                    particle.position.z = stars[star][2]-210;
                    particle.scale.x = particle.scale.y = 10;
                    particle.name=stars[star][3];
                    scene.add( particle );
                    particles.push(particle); 
                }
                
            }
            

            function particleRender( context ) {
                
                context.beginPath();
                context.arc( 0, 0, 1, 0,  Math.PI * 2, true );
                context.fill();
            };


            function onDocumentMouseUp( event ) {

                event.preventDefault();

                isMouseDown = false;
                onMouseDownPosition.x = event.clientX - onMouseDownPosition.x;
                onMouseDownPosition.y = event.clientY - onMouseDownPosition.y;

                if ( onMouseDownPosition.length() > 5 ) {

                    return;

                }

                update();

            }



            function onDocumentMouseDown( event ) {

                event.preventDefault();

                isMouseDown = true;
                rotate=false;

                onMouseDownTheta = theta;
                onMouseDownPhi = phi;
                onMouseDownPosition.x = event.clientX;
                onMouseDownPosition.y = event.clientY;

            }

            function onDocumentMouseMove( event ) {

                event.preventDefault();
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                position.x=event.clientX;
                position.y=event.clientY;
                if ( isMouseDown ) {

                    theta = - ( ( event.clientX - onMouseDownPosition.x ) * 0.5 ) + onMouseDownTheta;
                    phi = ( ( event.clientY - onMouseDownPosition.y ) * 0.5 ) + onMouseDownPhi;

                    phi = Math.min( 180, Math.max( 0, phi ) );

                    camera.position.x = radius * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                    camera.position.y = radius * Math.sin( phi * Math.PI / 360 );
                    camera.position.z = radius * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                    camera.updateMatrix();
                    update();
                }

            }

         function onDocumentMouseWheel( event ) {

                if (event.detail)
                {
                           radius -= event.detail*10;
                }
                if (event.wheelDelta)
                {
                     radius -=event.wheelDelta; 
                }
                update();

        }            
        </script>
<div id="test" style="position:absolute;z-index:10;color:white;display:none"></div>
    </body>
</html>
